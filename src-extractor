#!/usr/bin/env bash

# $1 - Start file
# $2 - Primary local include directory
# $3 - Package base directory

# set -x

extract-includes() {
    INCLUDES=$(grep "^# *include" $1 | sed 's/.*[<"]\(.*\)[>"].*/\1/')
    printf "%s\n" "${INCLUDES}"
}

# Resolved errors caused by multiple find results
# (quick fix via addition of file search order preference)
find-includes() {
    for include in $1; do
        # Search primary local include directory
        INCLUDE_PATH=$(find $2 -name $(basename $include))
        if [[ -n $INCLUDE_PATH ]]; then
            printf "%s\n" $INCLUDE_PATH
            continue
        fi
        
        # Search package base directory
        INCLUDE_PATH=$(find $3 -name $(basename $include))
        if [[ -n $INCLUDE_PATH ]]; then
            printf "%s\n" $INCLUDE_PATH
            continue
        fi

        # Search /usr/include if no match print to stderr
        INCLUDE_PATH=$(find /usr/include -name $(basename $include))
        if [[ -z $INCLUDE_PATH ]]; then
            printf "%s\n" $include 1>&2
        fi
    done
}

recursive-find-includes() {
    # Find initial include list
    INCLUDE_PATHS_1=$(find-includes "$(extract-includes $1)" $2 $3)
    
    # Recursively find all includes
    while [[ -n $INCLUDE_PATHS_1 ]]; do
        for include in $INCLUDE_PATHS_1; do
            # Prevent endless search recursion
            if ! [[ $INCLUDE_PATHS =~ $include ]]; then
                INCLUDE_PATHS+=$include$'\n'
                printf "%s\n" $include
                INCLUDE_PATHS_2+=$(find-includes "$(extract-includes $include)" $2 $3)$'\n'
            fi
        done
        INCLUDE_PATHS_1=$INCLUDE_PATHS_2
        INCLUDE_PATHS_2=""
    done
}

recursive-find-includes $1 $2 $3 2>/dev/null

